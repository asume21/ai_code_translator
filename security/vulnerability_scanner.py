"""
Core Vulnerability Scanner for AI Code Translator
Premium Feature for Advanced Version
"""

import os
import logging
import json
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
from .premium_manager import PremiumManager
import tkinter as tk
from tkinter import Toplevel, Text, Button, WORD
import datetime

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class VulnerabilitySeverity(Enum):
    """Severity levels for vulnerabilities"""
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"

@dataclass
class Vulnerability:
    """Represents a detected vulnerability"""
    line_number: int
    category: str
    description: str
    severity: VulnerabilitySeverity
    code_snippet: str
    fix_suggestion: str
    confidence: float = 1.0

class VulnerabilityScanner:
    """Main vulnerability scanner class with Gemini integration"""
    
    def __init__(self, premium_key: str = None, credentials_path: str = None):
        """Initialize the vulnerability scanner.
        
        Args:
            premium_key: Optional premium license key
            credentials_path: Path to service account credentials JSON file
        """
        self.premium_key = premium_key
        self.credentials_path = credentials_path
        
        # Initialize Gemini
        try:
            from ai_code_translator.gemini_interface import GeminiInterface
            self.gemini = GeminiInterface(
                credentials_path=credentials_path,
                model="models/gemini-1.5-pro-001"
            )
            logger.info("Gemini model initialized for vulnerability scanning")
        except Exception as e:
            logger.error(f"Failed to initialize Gemini model: {str(e)}")
            self.gemini = None
            
        # Initialize premium features if key provided
        self.premium_manager = PremiumManager()
        if premium_key:
            self.premium_manager.activate_license(premium_key)
            
        # Check premium status using PremiumManager
        self.is_premium = self.premium_manager.is_premium()
        self.vulnerabilities: List[Vulnerability] = []
        self.supported_languages = {
            'python': '.py',
            'javascript': '.js',
            'java': '.java',
            'cpp': ['.cpp', '.hpp', '.h'],
            'php': '.php'
        }
        
        # Load vulnerability patterns
        self.patterns = self._load_vulnerability_patterns()
        
    def _load_vulnerability_patterns(self) -> Dict:
        """Load vulnerability patterns from pattern files"""
        patterns = {}
        try:
            # Get absolute path to patterns directory
            current_dir = os.path.dirname(os.path.abspath(__file__))
            patterns_dir = os.path.join(current_dir, 'patterns')
            
            if not os.path.exists(patterns_dir):
                logger.error(f"Patterns directory not found: {patterns_dir}")
                # Create patterns directory if it doesn't exist
                os.makedirs(patterns_dir, exist_ok=True)
                
                # Create default pattern files
                default_patterns = {
                    'python': {
                        'sql_injection': {
                            'patterns': [
                                r'cursor\.execute\s*\([^)]*(?:\+|%|{)',
                                r'SELECT.*FROM.*WHERE.*=.*\+.*\+'
                            ],
                            'severity': 'HIGH',
                            'description': 'SQL injection vulnerability detected'
                        }
                    }
                }
                
                # Write default patterns
                for lang, lang_patterns in default_patterns.items():
                    pattern_file = os.path.join(patterns_dir, f'{lang}_patterns.json')
                    with open(pattern_file, 'w') as f:
                        json.dump(lang_patterns, f, indent=4)
                    logger.info(f"Created default pattern file: {pattern_file}")
                
            # Load patterns for each supported language
            for lang in self.supported_languages.keys():
                pattern_file = os.path.join(patterns_dir, f'{lang}_patterns.json')
                if os.path.exists(pattern_file):
                    try:
                        with open(pattern_file, 'r') as f:
                            patterns[lang] = json.load(f)
                        logger.info(f"Loaded {len(patterns[lang])} vulnerability patterns for {lang}")
                    except json.JSONDecodeError as e:
                        logger.error(f"Error parsing {pattern_file}: {str(e)}")
                    except Exception as e:
                        logger.error(f"Error loading {pattern_file}: {str(e)}")
                else:
                    logger.warning(f"Pattern file not found: {pattern_file}")
            
            return patterns
        except Exception as e:
            logger.error(f"Error loading vulnerability patterns: {str(e)}")
            return {}

    def _matches_pattern(self, line: str, pattern: str) -> bool:
        """Check if a line matches a vulnerability pattern"""
        import re
        try:
            if not line.strip() or not pattern.strip():
                return False
                
            logger.debug(f"Checking line: {line.strip()}")
            logger.debug(f"Against pattern: {pattern}")
            match = bool(re.search(pattern, line, re.IGNORECASE))
            if match:
                logger.info(f"Match found! Line: {line.strip()}")
            return match
        except Exception as e:
            logger.error(f"Error matching pattern '{pattern}': {str(e)}")
            return False

    async def scan_code(self, code: str, language: str) -> List[Vulnerability]:
        """Scan code for vulnerabilities using pattern matching and Gemini
        
        Args:
            code: Source code to scan
            language: Programming language of the code
            
        Returns:
            List of detected vulnerabilities
        """
        logger.info(f"Starting code scan for language: {language}")
        self.vulnerabilities = []
        
        # Debug: Print all available patterns
        logger.info(f"Available patterns: {list(self.patterns.keys())}")
        
        # Convert language to lowercase for case-insensitive matching
        language_lower = language.lower()
        
        if language_lower not in self.patterns:
            logger.warning(f"No patterns found for language: {language} (lowercase: {language_lower})")
            return self.vulnerabilities
            
        logger.info(f"Found {len(self.patterns[language_lower])} pattern categories for {language_lower}")
        lines = code.split('\n')
        
        # Pattern-based scanning
        for i, line in enumerate(lines, 1):
            for category, data in self.patterns[language_lower].items():
                for pattern in data['patterns']:
                    if self._matches_pattern(line, pattern):
                        logger.info(f"Found {category} vulnerability on line {i}")
                        fix = await self._get_fix_suggestion(category, line)
                        self.vulnerabilities.append(Vulnerability(
                            line_number=i,
                            category=category,
                            description=data.get('description', 'Unknown vulnerability'),
                            severity=VulnerabilitySeverity[data.get('severity', 'HIGH')],
                            code_snippet=line.strip(),
                            fix_suggestion=fix
                        ))
        
        # Gemini-enhanced scanning for premium users
        if self.is_premium and self.gemini:
            logger.info("Starting Gemini-enhanced scanning")
            try:
                gemini_results = await self._analyze_with_gemini(code, language)
                for vuln_type, description, confidence in gemini_results:
                    # Add only if it's a new type of vulnerability
                    if not any(v.category == vuln_type for v in self.vulnerabilities):
                        logger.info(f"Gemini found new vulnerability type: {vuln_type}")
                        fix = await self._get_fix_suggestion(vuln_type, code)
                        self.vulnerabilities.append(Vulnerability(
                            line_number=0,  # Gemini might not provide line numbers
                            category=vuln_type,
                            description=description,
                            severity=VulnerabilitySeverity.HIGH,  # Default to HIGH for Gemini findings
                            code_snippet=code,  # Include full code for context
                            fix_suggestion=fix,
                            confidence=confidence
                        ))
            except Exception as e:
                logger.error(f"Error during Gemini scanning: {str(e)}")
        
        logger.info(f"Scan complete. Found {len(self.vulnerabilities)} vulnerabilities")
        return self.vulnerabilities

    async def _get_fix_suggestion(self, category: str, code: str) -> str:
        """Get fix suggestion for a vulnerability using Gemini if available"""
        if not self.gemini:
            # Return basic fix suggestions based on category
            basic_fixes = {
                'sql_injection': 'Use parameterized queries with placeholders',
                'command_injection': 'Use subprocess with shell=False and proper argument escaping',
                'hardcoded_secrets': 'Use environment variables or secure secret management',
                'insecure_hash': 'Use stronger algorithms like SHA-256 or better',
                'pickle_usage': 'Use JSON or other safe serialization',
                'yaml_load': 'Use yaml.safe_load() instead',
                'debug_enabled': 'Disable debug mode in production'
            }
            return basic_fixes.get(category, 'Fix the vulnerability according to security best practices')
            
        try:
            prompt = f"Given this vulnerable code:\n{code}\n\nProvide a brief, specific fix for this {category} vulnerability."
            response = await self.gemini.generate_content(prompt)
            return response.text
        except Exception as e:
            logger.error(f"Error getting fix suggestion from Gemini: {str(e)}")
            return "Fix the vulnerability according to security best practices"

    def generate_report(self, output_format: str = 'text') -> str:
        """Generate a vulnerability report
        
        Args:
            output_format: 'text' or 'json'
            
        Returns:
            Formatted vulnerability report
        """
        if output_format == 'json':
            return self._generate_json_report()
        return self._generate_text_report()

    def _generate_text_report(self) -> str:
        """Generate a text-based vulnerability report"""
        report = [
            "Vulnerability Scan Report",
            f"Generated: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"Premium Features: {'Enabled' if self.is_premium else 'Disabled'}",
            f"Gemini Enhanced: {'Yes' if self.gemini else 'No'}",
            "\nFindings:",
            "=" * 80
        ]
        
        for vuln in self.vulnerabilities:
            report.extend([
                f"\nVulnerability Type: {vuln.category}",
                f"Severity: {vuln.severity.value}",
                f"Line Number: {vuln.line_number}",
                f"Description: {vuln.description}",
                f"Code: {vuln.code_snippet}",
                f"Fix Suggestion: {vuln.fix_suggestion}",
                "-" * 80
            ])
        
        return "\n".join(report)

    def _generate_json_report(self) -> str:
        """Generate a JSON vulnerability report"""
        report = {
            "scan_info": {
                "timestamp": datetime.datetime.now().isoformat(),
                "premium_enabled": self.is_premium,
                "gemini_enhanced": bool(self.gemini)
            },
            "vulnerabilities": [
                {
                    "category": v.category,
                    "severity": v.severity.value,
                    "line_number": v.line_number,
                    "description": v.description,
                    "code_snippet": v.code_snippet,
                    "fix_suggestion": v.fix_suggestion,
                    "confidence": v.confidence
                }
                for v in self.vulnerabilities
            ]
        }
        return json.dumps(report, indent=2)

    def show_report_dialog(self) -> None:
        """Show vulnerability report in a GUI dialog"""
        dialog = Toplevel()
        dialog.title("Vulnerability Report")
        
        # Create scrolled text widget
        report_text = Text(dialog, wrap=WORD, width=80, height=30)
        report_text.pack(expand=True, fill='both', padx=10, pady=10)
        
        # Insert report content
        report_text.insert('1.0', self._generate_text_report())
        report_text.config(state='disabled')
        
        # Add close button
        close_btn = Button(dialog, text="Close", command=dialog.destroy)
        close_btn.pack(pady=10)

    async def _analyze_with_gemini(self, code: str, language: str) -> List[Tuple[str, str, float]]:
        """Use Gemini to analyze code for vulnerabilities
        
        Args:
            code: Source code to analyze
            language: Programming language
            
        Returns:
            List of (vulnerability_type, description, confidence) tuples
        """
        if not self.gemini:
            return []
            
        prompt = f"""Analyze this {language} code for security vulnerabilities:

{code}

Provide a JSON response with this structure:
{{
    "vulnerabilities": [
        {{
            "type": "vulnerability type",
            "description": "detailed description",
            "confidence": confidence score between 0 and 1
        }}
    ]
}}

Focus on security issues like:
- Code injection
- Command injection
- SQL injection
- XSS vulnerabilities
- Unsafe deserialization
- Path traversal
- Etc.

Be thorough but avoid false positives."""

        try:
            response = await self.gemini.generate_content(prompt)
            result = json.loads(response.text)
            return [(v["type"], v["description"], v["confidence"]) 
                    for v in result["vulnerabilities"]]
        except Exception as e:
            logger.error(f"Error in Gemini analysis: {e}")
            return []
